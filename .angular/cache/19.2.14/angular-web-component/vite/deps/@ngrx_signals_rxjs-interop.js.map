{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngrx/signals/fesm2022/ngrx-signals-rxjs-interop.mjs"],
  "sourcesContent": ["import { assertInInjectionContext, inject, Injector, DestroyRef, isSignal, effect, untracked } from '@angular/core';\nimport { Subject, noop, isObservable } from 'rxjs';\nfunction rxMethod(generator, config) {\n  if (!config?.injector) {\n    assertInInjectionContext(rxMethod);\n  }\n  const sourceInjector = config?.injector ?? inject(Injector);\n  const source$ = new Subject();\n  const sourceSub = generator(source$).subscribe();\n  sourceInjector.get(DestroyRef).onDestroy(() => sourceSub.unsubscribe());\n  const rxMethodFn = (input, config) => {\n    if (isStatic(input)) {\n      source$.next(input);\n      return {\n        destroy: noop\n      };\n    }\n    const callerInjector = getCallerInjector();\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && config?.injector === undefined && callerInjector === undefined) {\n      console.warn('@ngrx/signals/rxjs-interop: The reactive method was called outside', 'the injection context with a signal or observable. This may lead to', 'a memory leak. Make sure to call it within the injection context', '(e.g. in a constructor or field initializer) or pass an injector', 'explicitly via the config parameter.\\n\\nFor more information, see:', 'https://ngrx.io/guide/signals/rxjs-integration#reactive-methods-and-injector-hierarchies');\n    }\n    const instanceInjector = config?.injector ?? callerInjector ?? sourceInjector;\n    if (isSignal(input)) {\n      const watcher = effect(() => {\n        const value = input();\n        untracked(() => source$.next(value));\n      }, {\n        injector: instanceInjector\n      });\n      sourceSub.add({\n        unsubscribe: () => watcher.destroy()\n      });\n      return watcher;\n    }\n    const instanceSub = input.subscribe(value => source$.next(value));\n    sourceSub.add(instanceSub);\n    if (instanceInjector !== sourceInjector) {\n      instanceInjector.get(DestroyRef).onDestroy(() => instanceSub.unsubscribe());\n    }\n    return {\n      destroy: () => instanceSub.unsubscribe()\n    };\n  };\n  rxMethodFn.destroy = sourceSub.unsubscribe.bind(sourceSub);\n  return rxMethodFn;\n}\nfunction isStatic(value) {\n  return !isSignal(value) && !isObservable(value);\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { rxMethod };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAEA,SAAS,SAAS,WAAW,QAAQ;AACnC,MAAI,CAAC,QAAQ,UAAU;AACrB,6BAAyB,QAAQ;AAAA,EACnC;AACA,QAAM,iBAAiB,QAAQ,YAAY,OAAO,QAAQ;AAC1D,QAAM,UAAU,IAAI,QAAQ;AAC5B,QAAM,YAAY,UAAU,OAAO,EAAE,UAAU;AAC/C,iBAAe,IAAI,UAAU,EAAE,UAAU,MAAM,UAAU,YAAY,CAAC;AACtE,QAAM,aAAa,CAAC,OAAOA,YAAW;AACpC,QAAI,SAAS,KAAK,GAAG;AACnB,cAAQ,KAAK,KAAK;AAClB,aAAO;AAAA,QACL,SAAS;AAAA,MACX;AAAA,IACF;AACA,UAAM,iBAAiB,kBAAkB;AACzC,QAAI,OAAO,cAAc,eAAe,aAAaA,SAAQ,aAAa,UAAa,mBAAmB,QAAW;AACnH,cAAQ,KAAK,sEAAsE,uEAAuE,oEAAoE,oEAAoE,sEAAsE,0FAA0F;AAAA,IACpc;AACA,UAAM,mBAAmBA,SAAQ,YAAY,kBAAkB;AAC/D,QAAI,SAAS,KAAK,GAAG;AACnB,YAAM,UAAU,OAAO,MAAM;AAC3B,cAAM,QAAQ,MAAM;AACpB,kBAAU,MAAM,QAAQ,KAAK,KAAK,CAAC;AAAA,MACrC,GAAG;AAAA,QACD,UAAU;AAAA,MACZ,CAAC;AACD,gBAAU,IAAI;AAAA,QACZ,aAAa,MAAM,QAAQ,QAAQ;AAAA,MACrC,CAAC;AACD,aAAO;AAAA,IACT;AACA,UAAM,cAAc,MAAM,UAAU,WAAS,QAAQ,KAAK,KAAK,CAAC;AAChE,cAAU,IAAI,WAAW;AACzB,QAAI,qBAAqB,gBAAgB;AACvC,uBAAiB,IAAI,UAAU,EAAE,UAAU,MAAM,YAAY,YAAY,CAAC;AAAA,IAC5E;AACA,WAAO;AAAA,MACL,SAAS,MAAM,YAAY,YAAY;AAAA,IACzC;AAAA,EACF;AACA,aAAW,UAAU,UAAU,YAAY,KAAK,SAAS;AACzD,SAAO;AACT;AACA,SAAS,SAAS,OAAO;AACvB,SAAO,CAAC,SAAS,KAAK,KAAK,CAAC,aAAa,KAAK;AAChD;AACA,SAAS,oBAAoB;AAC3B,MAAI;AACF,WAAO,OAAO,QAAQ;AAAA,EACxB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;",
  "names": ["config"]
}
