{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngrx/signals/fesm2022/ngrx-signals-entities.mjs", "../../../../../../node_modules/@angular-architects/ngrx-toolkit/fesm2022/angular-architects-ngrx-toolkit.mjs"],
  "sourcesContent": ["import { computed } from '@angular/core';\nimport { signalStoreFeature, withState, withComputed } from '@ngrx/signals';\nvar DidMutate;\n(function (DidMutate) {\n  DidMutate[DidMutate[\"None\"] = 0] = \"None\";\n  DidMutate[DidMutate[\"Entities\"] = 1] = \"Entities\";\n  DidMutate[DidMutate[\"Both\"] = 2] = \"Both\";\n})(DidMutate || (DidMutate = {}));\nconst defaultSelectId = entity => entity.id;\nfunction getEntityIdSelector(config) {\n  return config?.selectId ?? defaultSelectId;\n}\nfunction getEntityStateKeys(config) {\n  const collection = config?.collection;\n  const entityMapKey = collection === undefined ? 'entityMap' : `${collection}EntityMap`;\n  const idsKey = collection === undefined ? 'ids' : `${collection}Ids`;\n  const entitiesKey = collection === undefined ? 'entities' : `${collection}Entities`;\n  return {\n    entityMapKey,\n    idsKey,\n    entitiesKey\n  };\n}\nfunction cloneEntityState(state, stateKeys) {\n  return {\n    entityMap: {\n      ...state[stateKeys.entityMapKey]\n    },\n    ids: [...state[stateKeys.idsKey]]\n  };\n}\nfunction getEntityUpdaterResult(state, stateKeys, didMutate) {\n  switch (didMutate) {\n    case DidMutate.Both:\n      {\n        return {\n          [stateKeys.entityMapKey]: state.entityMap,\n          [stateKeys.idsKey]: state.ids\n        };\n      }\n    case DidMutate.Entities:\n      {\n        return {\n          [stateKeys.entityMapKey]: state.entityMap\n        };\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\nfunction addEntityMutably(state, entity, selectId, prepend = false) {\n  const id = selectId(entity);\n  if (state.entityMap[id]) {\n    return DidMutate.None;\n  }\n  state.entityMap[id] = entity;\n  if (prepend) {\n    state.ids.unshift(id);\n  } else {\n    state.ids.push(id);\n  }\n  return DidMutate.Both;\n}\nfunction addEntitiesMutably(state, entities, selectId, prepend = false) {\n  let didMutate = DidMutate.None;\n  for (const entity of entities) {\n    const result = addEntityMutably(state, entity, selectId, prepend);\n    if (result === DidMutate.Both) {\n      didMutate = result;\n    }\n  }\n  return didMutate;\n}\nfunction setEntityMutably(state, entity, selectId, replace = true) {\n  const id = selectId(entity);\n  if (state.entityMap[id]) {\n    state.entityMap[id] = replace ? entity : {\n      ...state.entityMap[id],\n      ...entity\n    };\n    return DidMutate.Entities;\n  }\n  state.entityMap[id] = entity;\n  state.ids.push(id);\n  return DidMutate.Both;\n}\nfunction setEntitiesMutably(state, entities, selectId, replace = true) {\n  let didMutate = DidMutate.None;\n  for (const entity of entities) {\n    const result = setEntityMutably(state, entity, selectId, replace);\n    if (didMutate === DidMutate.Both) {\n      continue;\n    }\n    didMutate = result;\n  }\n  return didMutate;\n}\nfunction removeEntitiesMutably(state, idsOrPredicate) {\n  const ids = Array.isArray(idsOrPredicate) ? idsOrPredicate : state.ids.filter(id => idsOrPredicate(state.entityMap[id]));\n  let didMutate = DidMutate.None;\n  for (const id of ids) {\n    if (state.entityMap[id]) {\n      delete state.entityMap[id];\n      didMutate = DidMutate.Both;\n    }\n  }\n  if (didMutate === DidMutate.Both) {\n    state.ids = state.ids.filter(id => id in state.entityMap);\n  }\n  return didMutate;\n}\nfunction updateEntitiesMutably(state, idsOrPredicate, changes, selectId) {\n  const ids = Array.isArray(idsOrPredicate) ? idsOrPredicate : state.ids.filter(id => idsOrPredicate(state.entityMap[id]));\n  let newIds = undefined;\n  let didMutate = DidMutate.None;\n  for (const id of ids) {\n    const entity = state.entityMap[id];\n    if (entity) {\n      const changesRecord = typeof changes === 'function' ? changes(entity) : changes;\n      state.entityMap[id] = {\n        ...entity,\n        ...changesRecord\n      };\n      didMutate = DidMutate.Entities;\n      const newId = selectId(state.entityMap[id]);\n      if (newId !== id) {\n        state.entityMap[newId] = state.entityMap[id];\n        delete state.entityMap[id];\n        newIds = newIds || {};\n        newIds[id] = newId;\n      }\n    }\n  }\n  if (newIds) {\n    state.ids = state.ids.map(id => newIds[id] ?? id);\n    didMutate = DidMutate.Both;\n  }\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && state.ids.length !== Object.keys(state.entityMap).length) {\n    console.warn('@ngrx/signals/entities: Entities with IDs:', ids, 'are not updated correctly.', 'Make sure to apply valid changes when using `updateEntity`,', '`updateEntities`, and `updateAllEntities` updaters.');\n  }\n  return didMutate;\n}\nfunction addEntity(entity, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = addEntityMutably(clonedState, entity, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction addEntities(entities, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = addEntitiesMutably(clonedState, entities, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction prependEntity(entity, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = addEntityMutably(clonedState, entity, selectId, true);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction prependEntities(entities, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const uniqueEntities = [];\n    const seenIds = new Set();\n    for (const entity of entities) {\n      const id = selectId(entity);\n      if (!seenIds.has(id)) {\n        uniqueEntities.unshift(entity);\n        seenIds.add(id);\n      }\n    }\n    const didMutate = addEntitiesMutably(clonedState, uniqueEntities, selectId, true);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction removeEntity(id, config) {\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = removeEntitiesMutably(clonedState, [id]);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction removeEntities(idsOrPredicate, config) {\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = removeEntitiesMutably(clonedState, idsOrPredicate);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction removeAllEntities(config) {\n  const stateKeys = getEntityStateKeys(config);\n  return () => ({\n    [stateKeys.entityMapKey]: {},\n    [stateKeys.idsKey]: []\n  });\n}\nfunction setEntity(entity, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = setEntityMutably(clonedState, entity, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction setEntities(entities, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = setEntitiesMutably(clonedState, entities, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction setAllEntities(entities, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return () => {\n    const state = {\n      entityMap: {},\n      ids: []\n    };\n    setEntitiesMutably(state, entities, selectId);\n    return {\n      [stateKeys.entityMapKey]: state.entityMap,\n      [stateKeys.idsKey]: state.ids\n    };\n  };\n}\nfunction updateEntity(update, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = updateEntitiesMutably(clonedState, [update.id], update.changes, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction updateEntities(update, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  const idsOrPredicate = 'ids' in update ? update.ids : update.predicate;\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = updateEntitiesMutably(clonedState, idsOrPredicate, update.changes, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction updateAllEntities(changes, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = updateEntitiesMutably(clonedState, state[stateKeys.idsKey], changes, selectId);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction upsertEntity(entity, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = setEntityMutably(clonedState, entity, selectId, false);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction upsertEntities(entities, config) {\n  const selectId = getEntityIdSelector(config);\n  const stateKeys = getEntityStateKeys(config);\n  return state => {\n    const clonedState = cloneEntityState(state, stateKeys);\n    const didMutate = setEntitiesMutably(clonedState, entities, selectId, false);\n    return getEntityUpdaterResult(clonedState, stateKeys, didMutate);\n  };\n}\nfunction entityConfig(config) {\n  return config;\n}\nfunction withEntities(config) {\n  const {\n    entityMapKey,\n    idsKey,\n    entitiesKey\n  } = getEntityStateKeys(config);\n  return signalStoreFeature(withState({\n    [entityMapKey]: {},\n    [idsKey]: []\n  }), withComputed(store => ({\n    [entitiesKey]: computed(() => {\n      const entityMap = store[entityMapKey]();\n      const ids = store[idsKey]();\n      return ids.map(id => entityMap[id]);\n    })\n  })));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { addEntities, addEntity, entityConfig, prependEntities, prependEntity, removeAllEntities, removeEntities, removeEntity, setAllEntities, setEntities, setEntity, updateAllEntities, updateEntities, updateEntity, upsertEntities, upsertEntity, withEntities };\n", "import { getState, signalStoreFeature, withMethods, withHooks, watchState, patchState as patchState$1, withState, withComputed, withProps } from '@ngrx/signals';\nimport * as i0 from '@angular/core';\nimport { inject, PLATFORM_ID, Injectable, signal, effect, InjectionToken, computed, isSignal, untracked, isDevMode as isDevMode$1 } from '@angular/core';\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { Subject } from 'rxjs';\nimport { setAllEntities, addEntity, updateEntity, removeEntity } from '@ngrx/signals/entities';\n\n/**\n * Stub for DevTools integration. Can be used to disable DevTools in production.\n */\nconst withDevToolsStub = () => store => store;\nconst currentActionNames = new Set();\nfunction throwIfNull(obj) {\n  if (obj === null || obj === undefined) {\n    throw new Error('');\n  }\n  return obj;\n}\nconst dummyConnection = {\n  send: () => void true\n};\n/**\n * A service provided by the root injector is\n * required because the synchronization runs\n * globally.\n *\n * The SignalStore could be provided in a component.\n * If the effect starts in the injection\n * context of the SignalStore, the complete sync\n * process would shut down once the component gets\n * destroyed.\n */\nclass DevtoolsSyncer {\n  /**\n   * Stores all SignalStores that are connected to the\n   * DevTools along their options, names and id.\n   */\n  #stores = {};\n  #isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n  #trackers = [];\n  /**\n   * Maintains the current states of all stores to avoid conflicts\n   * between glitch-free and glitched trackers when used simultaneously.\n   *\n   * The challenge lies in ensuring that glitched trackers do not\n   * interfere with the synchronization process of glitch-free trackers.\n   * Specifically, glitched trackers could cause the synchronization to\n   * read the current state of stores managed by glitch-free trackers.\n   *\n   * Therefore, the synchronization process doesn't read the state from\n   * each store, but relies on #currentState.\n   *\n   * Please note, that here the key is the name and not the id.\n   */\n  #currentState = {};\n  #currentId = 1;\n  #connection = this.#isBrowser ? window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n    name: 'NgRx SignalStore'\n  }) : dummyConnection : dummyConnection;\n  constructor() {\n    if (!this.#isBrowser) {\n      return;\n    }\n    const isToolkitAvailable = Boolean(window.__REDUX_DEVTOOLS_EXTENSION__);\n    if (!isToolkitAvailable) {\n      console.info('NgRx Toolkit/DevTools: Redux DevTools Extension is not available.');\n    }\n  }\n  ngOnDestroy() {\n    currentActionNames.clear();\n  }\n  syncToDevTools(changedStatePerId) {\n    const mappedChangedStatePerName = Object.entries(changedStatePerId).reduce((acc, [id, store]) => {\n      const {\n        options,\n        name\n      } = this.#stores[id];\n      acc[name] = options.map(store);\n      return acc;\n    }, {});\n    this.#currentState = {\n      ...this.#currentState,\n      ...mappedChangedStatePerName\n    };\n    const names = Array.from(currentActionNames);\n    const type = names.length ? names.join(', ') : 'Store Update';\n    currentActionNames.clear();\n    this.#connection.send({\n      type\n    }, this.#currentState);\n  }\n  getNextId() {\n    return String(this.#currentId++);\n  }\n  /**\n   * Consumer provides the id. That is because we can only start\n   * tracking the store in the init hook.\n   * Unfortunately, methods for renaming having the final id\n   * need to be defined already before.\n   * That's why `withDevtools` requests first the id and\n   * then registers itself later.\n   */\n  addStore(id, name, store, options) {\n    let storeName = name;\n    const names = Object.values(this.#stores).map(store => store.name);\n    if (names.includes(storeName)) {\n      // const { options } = throwIfNull(\n      //   Object.values(this.#stores).find((store) => store.name === storeName)\n      // );\n      if (!options.indexNames) {\n        throw new Error(`An instance of the store ${storeName} already exists. \\\nEnable automatic indexing via withDevTools('${storeName}', { indexNames: true }), or rename it upon instantiation.`);\n      }\n    }\n    for (let i = 1; names.includes(storeName); i++) {\n      storeName = `${name}-${i}`;\n    }\n    this.#stores[id] = {\n      name: storeName,\n      options\n    };\n    const tracker = options.tracker;\n    if (!this.#trackers.includes(tracker)) {\n      this.#trackers.push(tracker);\n    }\n    tracker.onChange(changedState => this.syncToDevTools(changedState));\n    tracker.track(id, store);\n  }\n  removeStore(id) {\n    const name = this.#stores[id].name;\n    this.#stores = Object.entries(this.#stores).reduce((newStore, [storeId, value]) => {\n      if (storeId !== id) {\n        newStore[storeId] = value;\n      }\n      return newStore;\n    }, {});\n    this.#currentState = Object.entries(this.#currentState).reduce((newState, [storeName, state]) => {\n      if (storeName !== name) {\n        newState[name] = state;\n      }\n      return newState;\n    }, {});\n    for (const tracker of this.#trackers) {\n      tracker.removeStore(id);\n    }\n  }\n  renameStore(oldName, newName) {\n    const storeNames = Object.values(this.#stores).map(store => store.name);\n    const id = throwIfNull(Object.keys(this.#stores).find(id => this.#stores[id].name === oldName));\n    if (storeNames.includes(newName)) {\n      throw new Error(`NgRx Toolkit/DevTools: cannot rename from ${oldName} to ${newName}. ${newName} is already assigned to another SignalStore instance.`);\n    }\n    this.#stores = Object.entries(this.#stores).reduce((newStore, [id, value]) => {\n      if (value.name === oldName) {\n        newStore[id] = {\n          ...value,\n          name: newName\n        };\n      } else {\n        newStore[id] = value;\n      }\n      return newStore;\n    }, {});\n    // we don't rename in #currentState but wait for tracker to notify\n    // us with a changed state that contains that name.\n    this.#currentState = Object.entries(this.#currentState).reduce((newState, [storeName, state]) => {\n      if (storeName !== oldName) {\n        newState[storeName] = state;\n      }\n      return newState;\n    }, {});\n    this.#trackers.forEach(tracker => tracker.notifyRenamedStore(id));\n  }\n  static {\n    this.Éµfac = function DevtoolsSyncer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DevtoolsSyncer)();\n    };\n  }\n  static {\n    this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n      token: DevtoolsSyncer,\n      factory: DevtoolsSyncer.Éµfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(DevtoolsSyncer, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass DefaultTracker {\n  #stores = signal({});\n  get stores() {\n    return this.#stores();\n  }\n  #trackCallback;\n  #trackingEffect = effect(() => {\n    if (this.#trackCallback === undefined) {\n      throw new Error('no callback function defined');\n    }\n    const stores = this.#stores();\n    const fullState = Object.entries(stores).reduce((acc, [id, store]) => {\n      return {\n        ...acc,\n        [id]: getState(store)\n      };\n    }, {});\n    this.#trackCallback(fullState);\n  });\n  track(id, store) {\n    this.#stores.update(value => ({\n      ...value,\n      [id]: store\n    }));\n  }\n  onChange(callback) {\n    this.#trackCallback = callback;\n  }\n  removeStore(id) {\n    this.#stores.update(stores => Object.entries(stores).reduce((newStore, [storeId, state]) => {\n      if (storeId !== id) {\n        newStore[storeId] = state;\n      }\n      return newStore;\n    }, {}));\n  }\n  notifyRenamedStore(id) {\n    if (this.#stores()[id]) {\n      this.#stores.update(stores => {\n        return {\n          ...stores\n        };\n      });\n    }\n  }\n  static {\n    this.Éµfac = function DefaultTracker_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultTracker)();\n    };\n  }\n  static {\n    this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n      token: DefaultTracker,\n      factory: DefaultTracker.Éµfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(DefaultTracker, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nconst renameDevtoolsMethodName = '___renameDevtoolsName';\nconst uniqueDevtoolsId = '___uniqueDevtoolsId';\nconst EXISTING_NAMES = new InjectionToken('Array contain existing names for the signal stores', {\n  factory: () => [],\n  providedIn: 'root'\n});\n/**\n * Adds this store as a feature state to the Redux DevTools.\n *\n * By default, the action name is 'Store Update'. You can\n * change that via the {@link updateState} method, which has as second\n * parameter the action name.\n *\n * The standalone function {@link renameDevtoolsName} can rename\n * the store name.\n *\n * @param name name of the store as it should appear in the DevTools\n * @param features features to extend or modify the behavior of the Devtools\n */\nfunction withDevtools(name, ...features) {\n  return signalStoreFeature(withMethods(() => {\n    const syncer = inject(DevtoolsSyncer);\n    const id = syncer.getNextId();\n    // TODO: use withProps and symbols\n    return {\n      [renameDevtoolsMethodName]: newName => {\n        syncer.renameStore(name, newName);\n      },\n      [uniqueDevtoolsId]: () => id\n    };\n  }), withHooks(store => {\n    const syncer = inject(DevtoolsSyncer);\n    const id = String(store[uniqueDevtoolsId]());\n    return {\n      onInit() {\n        const id = String(store[uniqueDevtoolsId]());\n        const finalOptions = {\n          indexNames: !features.some(f => f.indexNames === false),\n          map: features.find(f => f.map)?.map ?? (state => state),\n          tracker: inject(features.find(f => f.tracker)?.tracker || DefaultTracker)\n        };\n        syncer.addStore(id, name, store, finalOptions);\n      },\n      onDestroy() {\n        syncer.removeStore(id);\n      }\n    };\n  }));\n}\nconst DEVTOOLS_FEATURE = Symbol('DEVTOOLS_FEATURE');\nfunction createDevtoolsFeature(options) {\n  return {\n    [DEVTOOLS_FEATURE]: true,\n    ...options\n  };\n}\n\n/**\n * If multiple instances of the same SignalStore class\n * exist, their devtool names are indexed.\n *\n * For example:\n *\n * ```typescript\n * const Store = signalStore(\n *   withDevtools('flights')\n * )\n *\n * const store1 = new Store(); // will show up as 'flights'\n * const store2 = new Store(); // will show up as 'flights-1'\n * ```\n *\n * With adding `withDisabledNameIndices` to the store:\n * ```typescript\n * const Store = signalStore(\n *   withDevtools('flights', withDisabledNameIndices())\n * )\n *\n * const store1 = new Store(); // will show up as 'flights'\n * const store2 = new Store(); //ðŸ’¥ throws an error\n * ```\n *\n */\nfunction withDisabledNameIndices() {\n  return createDevtoolsFeature({\n    indexNames: false\n  });\n}\n\n/**\n * Allows you to define a function to map the state.\n *\n * It is needed for huge states, that slows down the Devtools and where\n * you don't need to see the whole state or other reasons.\n *\n * Example:\n *\n * ```typescript\n * const initialState = {\n *   id: 1,\n *   email: 'john.list@host.com',\n *   name: 'John List',\n *   enteredPassword: ''\n * }\n *\n * const Store = signalStore(\n *   withState(initialState),\n *   withDevtools(\n *     'user',\n *     withMapper(state => ({...state, enteredPassword: '***' }))\n *   )\n * )\n * ```\n *\n * @param map function which maps the state\n */\nfunction withMapper(map) {\n  return createDevtoolsFeature({\n    map: map\n  });\n}\n\n/**\n * Internal Service used by {@link withGlitchTracking}. It does not rely\n * on `effect` as {@link DefaultTracker} does but uses the NgRx function\n * `watchState` to track all state changes.\n */\nclass GlitchTrackerService {\n  #stores = {};\n  #callback;\n  get stores() {\n    return Object.entries(this.#stores).reduce((acc, [id, {\n      store\n    }]) => {\n      acc[id] = store;\n      return acc;\n    }, {});\n  }\n  onChange(callback) {\n    this.#callback = callback;\n  }\n  removeStore(id) {\n    this.#stores = Object.entries(this.#stores).reduce((newStore, [storeId, value]) => {\n      if (storeId !== id) {\n        newStore[storeId] = value;\n      } else {\n        value.destroyWatcher();\n      }\n      return newStore;\n    }, {});\n    throwIfNull(this.#callback)({});\n  }\n  track(id, store) {\n    const watcher = watchState(store, state => {\n      throwIfNull(this.#callback)({\n        [id]: state\n      });\n    });\n    this.#stores[id] = {\n      destroyWatcher: watcher.destroy,\n      store\n    };\n  }\n  notifyRenamedStore(id) {\n    if (Object.keys(this.#stores).includes(id) && this.#callback) {\n      this.#callback({\n        [id]: getState(this.#stores[id].store)\n      });\n    }\n  }\n  static {\n    this.Éµfac = function GlitchTrackerService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GlitchTrackerService)();\n    };\n  }\n  static {\n    this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n      token: GlitchTrackerService,\n      factory: GlitchTrackerService.Éµfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(GlitchTrackerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * It tracks all state changes of the State, including intermediary updates\n * that are typically suppressed by Angular's glitch-free mechanism.\n *\n * This feature is especially useful for debugging.\n *\n * Example:\n *\n * ```typescript\n * const Store = signalStore(\n *   { providedIn: 'root' },\n *   withState({ count: 0 }),\n *   withDevtools('counter', withGlitchTracking()),\n *   withMethods((store) => ({\n *     increase: () =>\n *       patchState(store, (value) => ({ count: value.count + 1 })),\n *   }))\n * );\n *\n * // would show up in the DevTools with value 0\n * const store = inject(Store);\n *\n * store.increase(); // would show up in the DevTools with value 1\n * store.increase(); // would show up in the DevTools with value 2\n * store.increase(); // would show up in the DevTools with value 3\n * ```\n *\n * Without `withGlitchTracking`, the DevTools would only show the final value of 3.\n */\nfunction withGlitchTracking() {\n  return createDevtoolsFeature({\n    tracker: GlitchTrackerService\n  });\n}\n\n/**\n * @deprecated Has been renamed to `updateState`\n */\nconst patchState = (state, action, ...rest) => {\n  updateState(state, action, ...rest);\n};\n/**\n * Wrapper of `patchState` for DevTools integration. Next to updating the state,\n * it also sends the action to the DevTools.\n * @param stateSource state of Signal Store\n * @param action name of action how it will show in DevTools\n * @param updaters updater functions or objects\n */\nfunction updateState(stateSource, action, ...updaters) {\n  currentActionNames.add(action);\n  return patchState$1(stateSource, ...updaters);\n}\n\n/**\n * Renames the name of a store how it appears in the Devtools.\n * @param store instance of the SignalStore\n * @param newName new name for the Devtools\n */\nfunction renameDevtoolsName(store, newName) {\n  const renameMethod = store[renameDevtoolsMethodName];\n  if (!renameMethod) {\n    throw new Error(\"Devtools extensions haven't been added to this store.\");\n  }\n  renameMethod(newName);\n}\nfunction assertActionFnSpecs(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new Error('%o is not an Action Specification');\n  }\n}\nfunction payload() {\n  return {};\n}\nconst noPayload = {};\n/**\n * Creates a reducer function to separate the reducer logic into another file.\n *\n * ```typescript\n * interface FlightState {\n *   flights: Flight[];\n *   effect1: boolean;\n *   effect2: boolean;\n * }\n *\n * const initialState: FlightState = {\n *   flights: [],\n *   effect1: false,\n *   effect2: false,\n * };\n *\n * const actions = {\n *   init: noPayload,\n *   updateEffect1: payload<{ value: boolean }>(),\n *   updateEffect2: payload<{ value: boolean }>(),\n * };\n *\n * const reducer = createReducer<FlightState, typeof actions>((actions, on) => {\n *   on(actions.updateEffect1, (state, { value }) => {\n *     patchState(state, { effect1: value });\n *   });\n *\n *   on(actions.updateEffect2, (state, { value }) => {\n *     patchState(state, { effect2: value });\n *   });\n * });\n *\n * signalStore(\n *   withState(initialState),\n *   withRedux({\n *     actions,\n *     reducer,\n *   })\n * );\n * ```\n * @param reducerFactory\n */\nfunction createReducer(reducerFactory) {\n  return reducerFactory;\n}\n/**\n * Creates the effects function to separate the effects logic into another file.\n *\n * ```typescript\n * interface FlightState {\n *   flights: Flight[];\n *   effect1: boolean;\n *   effect2: boolean;\n * }\n *\n * const initialState: FlightState = {\n *   flights: [],\n *   effect1: false,\n *   effect2: false,\n * };\n *\n * const actions = {\n *   init: noPayload,\n *   updateEffect1: payload<{ value: boolean }>(),\n *   updateEffect2: payload<{ value: boolean }>(),\n * };\n *\n * const effects = createEffects(actions, (actions, create) => {\n *   return {\n *     init1$: create(actions.init).pipe(\n *       map(() => actions.updateEffect1({ value: true }))\n *     ),\n *     init2$: create(actions.init).pipe(\n *       map(() => actions.updateEffect2({ value: true }))\n *     ),\n *   };\n * });\n *\n * signalStore(\n *   withState(initialState),\n *   withRedux({\n *     actions,\n *     effects,\n *   })\n * );\n * ```\n * @param actions\n * @param effectsFactory\n */\nfunction createEffects(actions, effectsFactory) {\n  return effectsFactory;\n}\nfunction createActionFns(actionFnSpecs, reducerRegistry, effectsRegistry, state) {\n  const actionFns = {};\n  for (const type in actionFnSpecs) {\n    const actionFn = payload => {\n      const fullPayload = {\n        ...payload,\n        type\n      };\n      const reducer = reducerRegistry[type];\n      if (reducer) {\n        reducer(state, fullPayload);\n      }\n      const effectSubjects = effectsRegistry[type];\n      if (effectSubjects?.length) {\n        for (const effectSubject of effectSubjects) {\n          effectSubject.next(fullPayload);\n        }\n      }\n      return fullPayload;\n    };\n    actionFn.type = type.toString();\n    actionFns[type] = actionFn;\n  }\n  return actionFns;\n}\nfunction createPublicAndAllActionsFns(actionFnSpecs, reducerRegistry, effectsRegistry, state) {\n  if ('public' in actionFnSpecs || 'private' in actionFnSpecs) {\n    const privates = actionFnSpecs['private'] || {};\n    const publics = actionFnSpecs['public'] || {};\n    assertActionFnSpecs(privates);\n    assertActionFnSpecs(publics);\n    const privateActionFns = createActionFns(privates, reducerRegistry, effectsRegistry, state);\n    const publicActionFns = createActionFns(publics, reducerRegistry, effectsRegistry, state);\n    return {\n      all: {\n        ...privateActionFns,\n        ...publicActionFns\n      },\n      publics: publicActionFns\n    };\n  }\n  const actionFns = createActionFns(actionFnSpecs, reducerRegistry, effectsRegistry, state);\n  return {\n    all: actionFns,\n    publics: actionFns\n  };\n}\nfunction fillReducerRegistry(reducer, actionFns, reducerRegistry) {\n  function on(action, reducerFn) {\n    reducerRegistry[action.type] = reducerFn;\n  }\n  reducer(actionFns, on);\n  return reducerRegistry;\n}\nfunction fillEffects(effects, actionFns, effectsRegistry = {}) {\n  function create(action) {\n    const subject = new Subject();\n    if (!(action.type in effectsRegistry)) {\n      effectsRegistry[action.type] = [];\n    }\n    effectsRegistry[action.type].push(subject);\n    return subject.asObservable();\n  }\n  const effectObservables = effects(actionFns, create);\n  return Object.values(effectObservables);\n}\nfunction startSubscriptions(observables) {\n  return observables.map(observable => observable.subscribe());\n}\nfunction processRedux(actionFnSpecs, reducer, effects, store) {\n  const reducerRegistry = {};\n  const effectsRegistry = {};\n  const actionsMap = createPublicAndAllActionsFns(actionFnSpecs, reducerRegistry, effectsRegistry, store);\n  const actionFns = actionsMap.all;\n  const publicActionsFns = actionsMap.publics;\n  fillReducerRegistry(reducer, actionFns, reducerRegistry);\n  const effectObservables = fillEffects(effects, actionFns, effectsRegistry);\n  const subscriptions = startSubscriptions(effectObservables);\n  return {\n    methods: publicActionsFns,\n    subscriptions: subscriptions\n  };\n}\n/**\n * @param redux redux\n *\n * properties do not start with `with` since they are not extension functions on their own.\n *\n * no dependency to NgRx\n *\n * actions are passed to reducer and effects, but it is also possible to use other actions.\n * effects provide forAction and do not return anything. that is important because effects should stay inaccessible\n */\nfunction withRedux(redux) {\n  return store => {\n    const {\n      methods\n    } = processRedux(redux.actions, redux.reducer, redux.effects, store);\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction getCallStateKeys(config) {\n  const prop = config?.collection;\n  return {\n    callStateKey: prop ? `${config.collection}CallState` : 'callState',\n    loadingKey: prop ? `${config.collection}Loading` : 'loading',\n    loadedKey: prop ? `${config.collection}Loaded` : 'loaded',\n    errorKey: prop ? `${config.collection}Error` : 'error'\n  };\n}\nfunction withCallState(config) {\n  const {\n    callStateKey,\n    errorKey,\n    loadedKey,\n    loadingKey\n  } = getCallStateKeys(config);\n  return signalStoreFeature(withState({\n    [callStateKey]: 'init'\n  }), withComputed(state => {\n    const callState = state[callStateKey];\n    return {\n      [loadingKey]: computed(() => callState() === 'loading'),\n      [loadedKey]: computed(() => callState() === 'loaded'),\n      [errorKey]: computed(() => {\n        const v = callState();\n        return typeof v === 'object' ? v.error : null;\n      })\n    };\n  }));\n}\nfunction setLoading(prop) {\n  if (prop) {\n    return {\n      [`${prop}CallState`]: 'loading'\n    };\n  }\n  return {\n    callState: 'loading'\n  };\n}\nfunction setLoaded(prop) {\n  if (prop) {\n    return {\n      [`${prop}CallState`]: 'loaded'\n    };\n  } else {\n    return {\n      callState: 'loaded'\n    };\n  }\n}\nfunction setError(error, prop) {\n  let errorMessage;\n  if (!error) {\n    errorMessage = '';\n  } else if (typeof error === 'object' && 'message' in error) {\n    errorMessage = String(error.message);\n  } else {\n    errorMessage = String(error);\n  }\n  if (prop) {\n    return {\n      [`${prop}CallState`]: {\n        error: errorMessage\n      }\n    };\n  } else {\n    return {\n      callState: {\n        error: errorMessage\n      }\n    };\n  }\n}\nfunction capitalize(str) {\n  return str ? str[0].toUpperCase() + str.substring(1) : str;\n}\nfunction getDataServiceKeys(options) {\n  const filterKey = options.collection ? `${options.collection}Filter` : 'filter';\n  const selectedIdsKey = options.collection ? `selected${capitalize(options.collection)}Ids` : 'selectedIds';\n  const selectedEntitiesKey = options.collection ? `selected${capitalize(options.collection)}Entities` : 'selectedEntities';\n  const updateFilterKey = options.collection ? `update${capitalize(options.collection)}Filter` : 'updateFilter';\n  const updateSelectedKey = options.collection ? `updateSelected${capitalize(options.collection)}Entities` : 'updateSelected';\n  const loadKey = options.collection ? `load${capitalize(options.collection)}Entities` : 'load';\n  const currentKey = options.collection ? `current${capitalize(options.collection)}` : 'current';\n  const loadByIdKey = options.collection ? `load${capitalize(options.collection)}ById` : 'loadById';\n  const setCurrentKey = options.collection ? `setCurrent${capitalize(options.collection)}` : 'setCurrent';\n  const createKey = options.collection ? `create${capitalize(options.collection)}` : 'create';\n  const updateKey = options.collection ? `update${capitalize(options.collection)}` : 'update';\n  const updateAllKey = options.collection ? `updateAll${capitalize(options.collection)}` : 'updateAll';\n  const deleteKey = options.collection ? `delete${capitalize(options.collection)}` : 'delete';\n  // TODO: Take these from @ngrx/signals/entities, when they are exported\n  const entitiesKey = options.collection ? `${options.collection}Entities` : 'entities';\n  const entityMapKey = options.collection ? `${options.collection}EntityMap` : 'entityMap';\n  const idsKey = options.collection ? `${options.collection}Ids` : 'ids';\n  return {\n    filterKey,\n    selectedIdsKey,\n    selectedEntitiesKey,\n    updateFilterKey,\n    updateSelectedKey,\n    loadKey,\n    entitiesKey,\n    entityMapKey,\n    idsKey,\n    currentKey,\n    loadByIdKey,\n    setCurrentKey,\n    createKey,\n    updateKey,\n    updateAllKey,\n    deleteKey\n  };\n}\nfunction withDataService(options) {\n  const {\n    dataServiceType,\n    filter,\n    collection: prefix\n  } = options;\n  const {\n    entitiesKey,\n    filterKey,\n    loadKey,\n    selectedEntitiesKey,\n    selectedIdsKey,\n    updateFilterKey,\n    updateSelectedKey,\n    currentKey,\n    createKey,\n    updateKey,\n    updateAllKey,\n    deleteKey,\n    loadByIdKey,\n    setCurrentKey\n  } = getDataServiceKeys(options);\n  const {\n    callStateKey\n  } = getCallStateKeys({\n    collection: prefix\n  });\n  return signalStoreFeature(withState(() => ({\n    [filterKey]: filter,\n    [selectedIdsKey]: {},\n    [currentKey]: undefined\n  })), withComputed(store => {\n    const entities = store[entitiesKey];\n    const selectedIds = store[selectedIdsKey];\n    return {\n      [selectedEntitiesKey]: computed(() => entities().filter(e => selectedIds()[e.id]))\n    };\n  }), withMethods(store => {\n    const dataService = inject(dataServiceType);\n    return {\n      [updateFilterKey]: filter => {\n        patchState$1(store, {\n          [filterKey]: filter\n        });\n      },\n      [updateSelectedKey]: (id, selected) => {\n        patchState$1(store, state => ({\n          [selectedIdsKey]: {\n            ...state[selectedIdsKey],\n            [id]: selected\n          }\n        }));\n      },\n      [loadKey]: async () => {\n        const filter = store[filterKey];\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const result = await dataService.load(filter());\n          patchState$1(store, prefix ? setAllEntities(result, {\n            collection: prefix\n          }) : setAllEntities(result));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [loadByIdKey]: async id => {\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const current = await dataService.loadById(id);\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n          patchState$1(store, {\n            [currentKey]: current\n          });\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [setCurrentKey]: current => {\n        patchState$1(store, {\n          [currentKey]: current\n        });\n      },\n      [createKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const created = await dataService.create(entity);\n          patchState$1(store, {\n            [currentKey]: created\n          });\n          patchState$1(store, prefix ? addEntity(created, {\n            collection: prefix\n          }) : addEntity(created));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [updateKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const updated = await dataService.update(entity);\n          patchState$1(store, {\n            [currentKey]: updated\n          });\n          const updateArg = {\n            id: updated.id,\n            changes: updated\n          };\n          const updater = collection => updateEntity(updateArg, {\n            collection\n          });\n          patchState$1(store, prefix ? updater(prefix) : updateEntity(updateArg));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [updateAllKey]: async entities => {\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const result = await dataService.updateAll(entities);\n          patchState$1(store, prefix ? setAllEntities(result, {\n            collection: prefix\n          }) : setAllEntities(result));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [deleteKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          await dataService.delete(entity);\n          patchState$1(store, {\n            [currentKey]: undefined\n          });\n          patchState$1(store, prefix ? removeEntity(entity.id, {\n            collection: prefix\n          }) : removeEntity(entity.id));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      }\n    };\n  }));\n}\nconst defaultOptions = {\n  maxStackSize: 100,\n  keys: [],\n  skip: 0\n};\nfunction getUndoRedoKeys(collections) {\n  if (collections) {\n    return collections.flatMap(c => [`${c}EntityMap`, `${c}Ids`, `selected${capitalize(c)}Ids`, `${c}Filter`]);\n  }\n  return ['entityMap', 'ids', 'selectedIds', 'filter'];\n}\nfunction withUndoRedo(options) {\n  let previous = null;\n  let skipOnce = false;\n  const normalized = {\n    ...defaultOptions,\n    ...options\n  };\n  //\n  // Design Decision: This feature has its own\n  // internal state.\n  //\n  const undoStack = [];\n  const redoStack = [];\n  const canUndo = signal(false);\n  const canRedo = signal(false);\n  const updateInternal = () => {\n    canUndo.set(undoStack.length !== 0);\n    canRedo.set(redoStack.length !== 0);\n  };\n  const keys = [...getUndoRedoKeys(normalized.collections), ...normalized.keys];\n  return signalStoreFeature(withComputed(() => ({\n    canUndo: canUndo.asReadonly(),\n    canRedo: canRedo.asReadonly()\n  })), withMethods(store => ({\n    undo() {\n      const item = undoStack.pop();\n      if (item && previous) {\n        redoStack.push(previous);\n      }\n      if (item) {\n        skipOnce = true;\n        patchState$1(store, item);\n        previous = item;\n      }\n      updateInternal();\n    },\n    redo() {\n      const item = redoStack.pop();\n      if (item && previous) {\n        undoStack.push(previous);\n      }\n      if (item) {\n        skipOnce = true;\n        patchState$1(store, item);\n        previous = item;\n      }\n      updateInternal();\n    },\n    clearStack() {\n      undoStack.splice(0);\n      redoStack.splice(0);\n      updateInternal();\n    }\n  })), withHooks({\n    onInit(store) {\n      effect(() => {\n        const cand = keys.reduce((acc, key) => {\n          const s = store[key];\n          if (s && isSignal(s)) {\n            return {\n              ...acc,\n              [key]: s()\n            };\n          }\n          return acc;\n        }, {});\n        if (normalized.skip > 0) {\n          normalized.skip--;\n          return;\n        }\n        if (skipOnce) {\n          skipOnce = false;\n          return;\n        }\n        //\n        // Deep Comparison to prevent duplicated entries\n        // on the stack. This can e.g. happen after an undo\n        // if the component sends back the undone filter\n        // to the store.\n        //\n        if (JSON.stringify(cand) === JSON.stringify(previous)) {\n          return;\n        }\n        // Clear redoStack after recorded action\n        redoStack.splice(0);\n        if (previous) {\n          undoStack.push(previous);\n        }\n        if (redoStack.length > normalized.maxStackSize) {\n          undoStack.unshift();\n        }\n        previous = cand;\n        // Don't propogate current reactive context\n        untracked(() => updateInternal());\n      });\n    }\n  }));\n}\nconst NOOP = () => void true;\nconst StorageSyncStub = {\n  clearStorage: NOOP,\n  readFromStorage: NOOP,\n  writeToStorage: NOOP\n};\nfunction withStorageSync(configOrKey) {\n  const {\n    key,\n    autoSync = true,\n    select = state => state,\n    parse = JSON.parse,\n    stringify = JSON.stringify,\n    storage: storageFactory = () => localStorage\n  } = typeof configOrKey === 'string' ? {\n    key: configOrKey\n  } : configOrKey;\n  return signalStoreFeature(withMethods((store, platformId = inject(PLATFORM_ID)) => {\n    if (isPlatformServer(platformId)) {\n      console.warn(`'withStorageSync' provides non-functional implementation due to server-side execution`);\n      return StorageSyncStub;\n    }\n    const storage = storageFactory();\n    return {\n      /**\n       * Removes the item stored in storage.\n       */\n      clearStorage() {\n        storage.removeItem(key);\n      },\n      /**\n       * Reads item from storage and patches the state.\n       */\n      readFromStorage() {\n        const stateString = storage.getItem(key);\n        if (stateString) {\n          patchState$1(store, parse(stateString));\n        }\n      },\n      /**\n       * Writes selected portion to storage.\n       */\n      writeToStorage() {\n        const slicedState = select(getState(store));\n        storage.setItem(key, stringify(slicedState));\n      }\n    };\n  }), withHooks({\n    onInit(store, platformId = inject(PLATFORM_ID)) {\n      if (isPlatformServer(platformId)) {\n        return;\n      }\n      if (autoSync) {\n        store.readFromStorage();\n        effect(() => {\n          store.writeToStorage();\n        });\n      }\n    }\n  }));\n}\n\n/** With pagination comes in two flavors the first one is local pagination or in memory pagination. For example we have 2000 items which we want\n * to display in a table and the response payload is small enough to be stored in the memory. But we can not display all 2000 items at once\n * so we need to paginate the data. The second flavor is server side pagination where the response payload is too large to be stored in the memory\n * and we need to fetch the data from the server in chunks. In the second case we 'could' also cache the data in the memory but that could lead to\n * other problems like memory leaks and stale data. So we will not cache the data in the memory in the second case.\n * This feature implements the local pagination.\n */\nfunction withPagination(options) {\n  const {\n    pageKey,\n    pageSizeKey,\n    entitiesKey,\n    selectedPageEntitiesKey,\n    totalCountKey,\n    pageCountKey,\n    pageNavigationArrayMaxKey,\n    pageNavigationArrayKey,\n    hasNextPageKey,\n    hasPreviousPageKey\n  } = createPaginationKeys(options);\n  return signalStoreFeature(withState({\n    [pageKey]: 0,\n    [pageSizeKey]: 10,\n    [pageNavigationArrayMaxKey]: 7\n  }), withComputed(store => {\n    const entities = store[entitiesKey];\n    const page = store[pageKey];\n    const pageSize = store[pageSizeKey];\n    const pageNavigationArrayMax = store[pageNavigationArrayMaxKey];\n    return {\n      // The derived enitites which are displayed on the current page\n      [selectedPageEntitiesKey]: computed(() => {\n        const pageSizeValue = pageSize();\n        const pageValue = page();\n        return entities().slice(pageValue * pageSizeValue, (pageValue + 1) * pageSizeValue);\n      }),\n      [totalCountKey]: computed(() => entities().length),\n      [pageCountKey]: computed(() => {\n        const totalCountValue = entities().length;\n        const pageSizeValue = pageSize();\n        if (totalCountValue === 0) {\n          return 0;\n        }\n        return Math.ceil(totalCountValue / pageSizeValue);\n      }),\n      [pageNavigationArrayKey]: computed(() => createPageArray(page(), pageSize(), entities().length, pageNavigationArrayMax())),\n      [hasNextPageKey]: computed(() => {\n        return page() < pageSize();\n      }),\n      [hasPreviousPageKey]: computed(() => {\n        return page() > 1;\n      })\n    };\n  }));\n}\nfunction gotoPage(page, options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: page\n  };\n}\nfunction setPageSize(pageSize, options) {\n  const {\n    pageSizeKey\n  } = createPaginationKeys(options);\n  return {\n    [pageSizeKey]: pageSize\n  };\n}\nfunction nextPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: currentPage => currentPage + 1\n  };\n}\nfunction previousPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: currentPage => Math.max(currentPage - 1, 1)\n  };\n}\nfunction firstPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: 1\n  };\n}\nfunction setMaxPageNavigationArrayItems(maxPageNavigationArrayItems, options) {\n  const {\n    pageNavigationArrayMaxKey\n  } = createPaginationKeys(options);\n  return {\n    [pageNavigationArrayMaxKey]: maxPageNavigationArrayItems\n  };\n}\nfunction createPaginationKeys(options) {\n  const entitiesKey = options?.collection ? `${options.collection}Entities` : 'entities';\n  const selectedPageEntitiesKey = options?.collection ? `selectedPage${capitalize(options?.collection)}Entities` : 'selectedPageEntities';\n  const pageKey = options?.collection ? `${options.collection}CurrentPage` : 'currentPage';\n  const pageSizeKey = options?.collection ? `${options.collection}PageSize` : 'pageSize';\n  const totalCountKey = options?.collection ? `${options.collection}TotalCount` : 'totalCount';\n  const pageCountKey = options?.collection ? `${options.collection}PageCount` : 'pageCount';\n  const pageNavigationArrayMaxKey = options?.collection ? `${options.collection}PageNavigationArrayMax` : 'pageNavigationArrayMax';\n  const pageNavigationArrayKey = options?.collection ? `${options.collection}PageNavigationArray` : 'pageNavigationArray';\n  const hasNextPageKey = options?.collection ? `hasNext${capitalize(options.collection)}Page` : 'hasNextPage';\n  const hasPreviousPageKey = options?.collection ? `hasPrevious${capitalize(options.collection)}Page` : 'hasPreviousPage';\n  return {\n    pageKey,\n    pageSizeKey,\n    entitiesKey,\n    selectedPageEntitiesKey,\n    totalCountKey,\n    pageCountKey,\n    pageNavigationArrayKey,\n    pageNavigationArrayMaxKey,\n    hasNextPageKey,\n    hasPreviousPageKey\n  };\n}\nfunction createPageArray(currentPage, itemsPerPage, totalItems, paginationRange) {\n  // Convert paginationRange to number in case it's a string\n  paginationRange = +paginationRange;\n  // Calculate total number of pages\n  const totalPages = Math.max(Math.ceil(totalItems / itemsPerPage), 1);\n  const halfWay = Math.ceil(paginationRange / 2);\n  const isStart = currentPage <= halfWay;\n  const isEnd = totalPages - halfWay < currentPage;\n  const isMiddle = !isStart && !isEnd;\n  const ellipsesNeeded = paginationRange < totalPages;\n  const pages = [];\n  for (let i = 1; i <= totalPages && i <= paginationRange; i++) {\n    let pageNumber = i;\n    if (i === paginationRange) {\n      pageNumber = totalPages;\n    } else if (ellipsesNeeded) {\n      if (isEnd) {\n        pageNumber = totalPages - paginationRange + i;\n      } else if (isMiddle) {\n        pageNumber = currentPage - halfWay + i;\n      }\n    }\n    const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);\n    const closingEllipsesNeeded = i === paginationRange - 1 && (isMiddle || isStart);\n    const label = ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded) ? '...' : pageNumber;\n    pages.push({\n      label,\n      value: pageNumber\n    });\n  }\n  return pages;\n}\n\n/**\n * Adds a `resetState` method to the store, which resets the state\n * to the initial state.\n *\n * If you want to set a custom initial state, you can use {@link setResetState}.\n */\nfunction withReset() {\n  return signalStoreFeature(withProps(() => ({\n    _resetState: {\n      value: {}\n    }\n  })), withMethods(store => {\n    // workaround to TS excessive property check\n    const methods = {\n      resetState() {\n        patchState$1(store, store._resetState.value);\n      },\n      __setResetState__(state) {\n        store._resetState.value = state;\n      }\n    };\n    return methods;\n  }), withHooks(store => ({\n    onInit() {\n      store._resetState.value = getState(store);\n    }\n  })));\n}\n/**\n * Sets the reset state of the store to the given state.\n *\n * Throws an error if the store is not configured with {@link withReset}.\n * @param store the instance of a SignalStore\n * @param state the state to set as the reset state\n */\nfunction setResetState(store, state) {\n  if (!('__setResetState__' in store)) {\n    throw new Error('Cannot set reset state, since store is not configured with withReset()');\n  }\n  store.__setResetState__(state);\n}\n\n/**\n * Deep freezes a state object along its properties with primitive values\n * on the first level.\n *\n * The reason for this is that the final state is a merge of all\n * root properties of all states, i.e. `withState`,....\n *\n * Since the root object will not be part of the state (shadow clone),\n * we are not freezing it.\n */\nfunction deepFreeze(target,\n// if empty all properties will be frozen\npropertyNamesToBeFrozen,\n// also means that we are on the first level\nisRoot = true) {\n  const runPropertyNameCheck = propertyNamesToBeFrozen.length > 0;\n  for (const key of Reflect.ownKeys(target)) {\n    if (runPropertyNameCheck && !propertyNamesToBeFrozen.includes(key)) {\n      continue;\n    }\n    const propValue = target[key];\n    if (isRecordLike(propValue) && !Object.isFrozen(propValue)) {\n      Object.freeze(propValue);\n      deepFreeze(propValue, [], false);\n    } else if (isRoot) {\n      Object.defineProperty(target, key, {\n        value: propValue,\n        writable: false,\n        configurable: false\n      });\n    }\n  }\n}\nfunction isRecordLike(target) {\n  return typeof target === 'object' && target !== null;\n}\n\n// necessary wrapper function to test prod mode\nfunction isDevMode() {\n  return isDevMode$1();\n}\nfunction withImmutableState(stateOrFactory, options) {\n  const immutableState = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n  const stateKeys = Reflect.ownKeys(immutableState);\n  const applyFreezing = isDevMode() || options?.enableInProduction === true;\n  return signalStoreFeature(withState(immutableState), withHooks(store => ({\n    onInit() {\n      if (!applyFreezing) {\n        return;\n      }\n      /**\n       * `immutableState` will be initially frozen. That is because\n       * of potential mutations outside the SignalStore\n       *\n       * ```ts\n       * const initialState = {id: 1};\n       * signalStore(withImmutableState(initialState));\n       *\n       * initialState.id = 2; // must throw immutability\n       * ```\n       */\n      Object.freeze(immutableState);\n      watchState(store, state => {\n        deepFreeze(state, stateKeys);\n      });\n    }\n  })));\n}\n\n/**\n * Allows to pass properties, methods, or signals from a SignalStore\n * to a feature.\n *\n * Typically, a `signalStoreFeature` can have input constraints on\n *\n * ```typescript\n * function withSum(a: Signal<number>, b: Signal<number>) {\n *   return signalStoreFeature(\n *     withComputed(() => ({\n *       sum: computed(() => a() + b())\n *     }))\n *   );\n * }\n *\n * signalStore(\n *   withState({ a: 1, b: 2 }),\n *   withFeatureFactory((store) => withSum(store.a, store.b))\n * );\n * ```\n * @param factoryFn\n */\nfunction withFeatureFactory(factoryFn) {\n  return store => {\n    const storeForFactory = {\n      ...store['stateSignals'],\n      ...store['props'],\n      ...store['methods']\n    };\n    const feature = factoryFn(storeForFactory);\n    return feature(store);\n  };\n}\n\n/**\n * `withConditional` activates a feature based on a given condition.\n *\n * **Use Cases**\n * - Conditionally activate features based on the **store state** or other criteria.\n * - Choose between **two different implementations** of a feature.\n *\n * **Type Constraints**\n * Both features must have **exactly the same state, props, and methods**.\n * Otherwise, a type error will occur.\n *\n *\n * **Usage**\n *\n * ```typescript\n * const withUser = signalStoreFeature(\n *   withState({ id: 1, name: 'Konrad' }),\n *   withHooks(store => ({\n *     onInit() {\n *       // user loading logic\n *     }\n *   }))\n * );\n *\n * function withFakeUser() {\n *   return signalStoreFeature(\n *     withState({ id: 0, name: 'anonymous' })\n *   );\n * }\n *\n * signalStore(\n *   withMethods(() => ({\n *     useRealUser: () => true\n *   })),\n *   withConditional((store) => store.useRealUser(), withUser, withFakeUser)\n * )\n * ```\n *\n * @param condition - A function that determines which feature to activate based on the store state.\n * @param featureIfTrue - The feature to activate if the condition evaluates to `true`.\n * @param featureIfFalse - The feature to activate if the condition evaluates to `false`.\n * @returns A `SignalStoreFeature` that applies the selected feature based on the condition.\n */\nfunction withConditional(condition, featureIfTrue, featureIfFalse) {\n  return store => {\n    const conditionStore = {\n      ...store['stateSignals'],\n      ...store['props'],\n      ...store['methods']\n    };\n    return condition(conditionStore) ? featureIfTrue(store) : featureIfFalse(store);\n  };\n}\nconst emptyFeature = signalStoreFeature(withState({}));\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { capitalize, createEffects, createPageArray, createReducer, emptyFeature, firstPage, getCallStateKeys, getDataServiceKeys, getUndoRedoKeys, gotoPage, nextPage, noPayload, patchState, payload, previousPage, renameDevtoolsName, setError, setLoaded, setLoading, setMaxPageNavigationArrayItems, setPageSize, setResetState, updateState, withCallState, withConditional, withDataService, withDevToolsStub, withDevtools, withDisabledNameIndices, withFeatureFactory, withGlitchTracking, withImmutableState, withMapper, withPagination, withRedux, withReset, withStorageSync, withUndoRedo };\n"],
  "mappings": "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",
  "names": ["DidMutate", "store", "id", "patchState", "payload", "filter", "isDevMode"]
}
